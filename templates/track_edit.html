{% extends "layout.html" %}

{% block title %}
    Edit {{title}}
{% endblock %}

{% block main %}
    <form action="/track_edit" method="post">
      <div class="button-container">
        <input class="edit_buttons_top" type ="submit" name="left"     value = "Left curve &ShortLeftArrow; ({{ counter.curve }} / {{ user_lib.curve }})">
        <input class="edit_buttons_top" type ="submit" name="straight" value = "Straight &ShortUpArrow;  ({{ counter.straight }} / {{ user_lib.straight }})">
        <input class="edit_buttons_top" type ="submit" name="right"    value = "Right curve &ShortRightArrow;  ({{ counter.curve }} / {{ user_lib.curve }})">
        <input class="edit_buttons_top" type ="submit" name="switch"   value = "Switch  ({{ counter.switch }} / {{ user_lib.switch }})">
        <input class="edit_buttons_top" type ="submit" name="crossing" value = "Crossing  ({{ counter.crossing }} / {{ user_lib.crossing }})">
      </div>
      <div class="button-container">
        <input class="edit_buttons_bottom" type ="submit" name="rotate"      value = "Rotate piece &circlearrowright;">
        <input class="edit_buttons_bottom" type ="submit" name="next_ending" value = "Next ending &#x23E9;">
        <input class="edit_buttons_bottom" type ="submit" name="save"     value = "Save &#128190;">
        <input class="edit_buttons_bottom" type ="submit" name="delete"   value = "Delete &#10060;">
      </div>
    </form>

    <br>
    <canvas id="drawingCanvas" width="500" height="500"></canvas>
    <script>

      function drawElement(ctx, path, color) {        
        ctx.beginPath();
        ctx.strokeStyle = color;
        for (let i = 0; i < path.length; i++) {
          // HTML canvas is inverted
          ctx.lineTo(path[i].x, 500 - path[i].y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      class Transform {
        constructor(ctx) {
          this.ctx = ctx;
          this.s = 1;
          this.dx = 0;
          this.dy = 0;
        }
        
        scale(s) {
          this.ctx.scale(s, s);
          this.s *= 1 / s;
          this.dx *= 1 / s;
          this.dy *= 1 / s;
        }
        
        translate(dx, dy) {
          this.ctx.translate(dx, dy);
          this.dx -= dx;
          this.dy -= dy;
        }
        
        transform({ x, y }) {
          return {
            x: this.s * x + this.dx,
            y: this.s * y + this.dy
          };
        }
      }
      
      class PanAndZoom {
        constructor(canvas, draw) {
          this.canvas = canvas;
          this.ctx = this.canvas.getContext('2d');
          this.onDraw = draw;
          this.transform = new Transform(this.ctx);
          
          this.canvas.addEventListener('wheel', e => this.onWheel(e));
          this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
          this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
          this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
          
          this.draw();
        }
        
        draw() {
          this.onDraw(this.ctx, this.transform);
        }
      
        mouseOffset(e) {
            return { x: e.pageX - this.canvas.offsetLeft, y: e.pageY - this.canvas.offsetTop };
        }
      
        onMouseDown(e, ctx) {
          e.preventDefault();
          e.stopPropagation();
          this.dragStart = this.transform.transform(this.mouseOffset(e));
          this.dragging = true;
        }
      
        onMouseMove(e, ctx) {
          e.preventDefault();
          e.stopPropagation();
      
          if (!this.dragging) {
            return;
          }
      
          const offset = this.mouseOffset(e);
          const dragEnd = this.transform.transform(offset);
          const dx = dragEnd.x - this.dragStart.x;
          const dy = dragEnd.y - this.dragStart.y;
          this.transform.translate(dx, dy);
          this.draw();
          this.dragStart = this.transform.transform(offset);
        }
      
        onMouseUp(e, ctx) {
          e.preventDefault();
          e.stopPropagation();
      
          this.dragging = false;
        }
      
        onWheel(e, ctx) {
          e.preventDefault();
          e.stopPropagation();
      
          const offset = this.mouseOffset(e);
          const t = this.transform.transform(offset);
          this.transform.translate(t.x, t.y);
          const factor = Math.sign(e.deltaY) > 0 ? 0.9 : 1.1;
          this.transform.scale(factor);
          this.transform.translate(-t.x, -t.y);
          this.draw();
        }
      }
      
      function clearCanvas(ctx, transform) {
        const { x: left, y: top } = transform.transform({ x: 0, y: 0 });
        const { x: right, y: bottom } = transform.transform({ x: ctx.canvas.width, y: ctx.canvas.height });
        const width = Math.abs(right - left);
        const height = Math.abs(bottom - top);
        ctx.fillStyle = 'white';
        ctx.fillRect(left, top, width, height);
      }
            
      function draw(ctx, transform) {
        clearCanvas(ctx, transform);
        {% for el in pathes %}
        drawElement(ctx,{{el.path | tojson}}, '{{el.color}}');
        {% endfor %}
      }
      
      function run() {
        const canvas = document.getElementById('drawingCanvas');
        const panAndZoom = new PanAndZoom(canvas, draw);
      }
      
      document.addEventListener('DOMContentLoaded', run);
      
    </script>
{% endblock %}