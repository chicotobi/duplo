{% extends "layout.html" %}

{% block title %}
    Edit {{title}}
{% endblock %}

{% block main %}
    <form action="/track_edit" method="post">
      <div class="button-container">
        <input class="edit_buttons_top" type ="submit" name="left"     value = "Left curve &ShortLeftArrow; ({{ counter.curve }} / {{ user_lib.curve }})">
        <input class="edit_buttons_top" type ="submit" name="straight" value = "Straight &ShortUpArrow;  ({{ counter.straight }} / {{ user_lib.straight }})">
        <input class="edit_buttons_top" type ="submit" name="right"    value = "Right curve &ShortRightArrow;  ({{ counter.curve }} / {{ user_lib.curve }})">
        <input class="edit_buttons_top" type ="submit" name="switch"   value = "Switch  ({{ counter.switch }} / {{ user_lib.switch }})">
        <input class="edit_buttons_top" type ="submit" name="crossing" value = "Crossing  ({{ counter.crossing }} / {{ user_lib.crossing }})">
      </div>
      <div class="button-container">
        <input class="edit_buttons_bottom" type ="submit" name="rotate"      value = "Rotate piece &circlearrowright;">
        <input class="edit_buttons_bottom" type ="submit" name="next_ending" value = "Next ending &#x23E9;">
        <input class="edit_buttons_bottom" type ="submit" name="save"     value = "Save &#128190;">
        <input class="edit_buttons_bottom" type ="submit" name="delete"   value = "Delete &#10060;">
      </div>
    </form>

    <br>
    <canvas id="drawingCanvas" width="500" height="500"></canvas>
    <script>

      const canvas = document.getElementById('drawingCanvas');
      const ctx = canvas.getContext('2d');
      
      let scale = 1;
      let posX = 0;
      let posY = 0;
      let lastTouchEnd = 0;
      
      function drawElement(path, color) {        
        ctx.beginPath();
        ctx.strokeStyle = color;
        for (let i = 0; i < path.length; i++) {
          // HTML canvas is inverted
          ctx.lineTo(path[i].x, 500 - path[i].y);
        }
        ctx.closePath();
        ctx.stroke();
      }
      
      const draw = () => {
          ctx.save();
          ctx.setTransform(scale, 0, 0, scale, posX, posY);
          ctx.clearRect(-posX / scale, -posY / scale, canvas.width / scale, canvas.height / scale);
                
          {% for el in pathes %}
          drawElement({{el.path | tojson}}, '{{el.color}}');
          {% endfor %}
          
          ctx.restore();
      };
      
      const handleTouchStart = (evt) => {
          evt.preventDefault();  // Prevent default touch actions
          if (evt.touches.length === 1) {
              // Single touch - start panning
              let touch = evt.touches[0];
              canvas.dataset.startX = touch.pageX - posX;
              canvas.dataset.startY = touch.pageY - posY;
          }
          if (evt.touches.length === 2) {
              // Two fingers - start zooming
              const dx = evt.touches[0].pageX - evt.touches[1].pageX;
              const dy = evt.touches[0].pageY - evt.touches[1].pageY;
              canvas.dataset.startDistance = Math.sqrt(dx * dx + dy * dy);
              canvas.dataset.startScale = scale;
          }
      };
      
      const handleTouchMove = (evt) => {
          evt.preventDefault();  // Prevent default touch actions
          if (evt.touches.length === 1) {
              // Single touch - panning
              let touch = evt.touches[0];
              posX = touch.pageX - canvas.dataset.startX;
              posY = touch.pageY - canvas.dataset.startY;
          }
      
          if (evt.touches.length === 2) {
              // Two fingers - zooming
              const dx = evt.touches[0].pageX - evt.touches[1].pageX;
              const dy = evt.touches[0].pageY - evt.touches[1].pageY;
              const newDistance = Math.sqrt(dx * dx + dy * dy);
              const newScale = (newDistance / canvas.dataset.startDistance) * canvas.dataset.startScale;
              scale = newScale > 0.1 ? Math.min(newScale, 10) : 0.1; // Ensure scale stays within a reasonable range
          }
          draw();
      };
      
      const handleTouchEnd = (evt) => {
          evt.preventDefault();  // Prevent default touch actions
          const now = new Date().getTime();
          if (now - lastTouchEnd <= 300) {
              // Double-tap detected - reset pan and zoom
              scale = 1;
              posX = 0;
              posY = 0;
          }
          lastTouchEnd = now;
          draw();
      };
            
      const handleMouseDown = (evt) => {
        evt.preventDefault();
        isDragging = true;
        startX = evt.pageX - posX;
        startY = evt.pageY - posY;
      };

      const handleMouseMove = (evt) => {
        if (!isDragging) return;
        evt.preventDefault();
        posX = evt.pageX - startX;
        posY = evt.pageY - startY;
        draw();
      };

      const handleMouseUp = () => {
        isDragging = false;
      };

      const handleMouseWheel = (evt) => {
        evt.preventDefault();
        const delta = evt.deltaY < 0 ? 1.1 : 0.9;
        const newScale = scale * delta;
        if (newScale >= 0.1 && newScale <= 10) {
            const mouseX = evt.pageX - canvas.offsetLeft;
            const mouseY = evt.pageY - canvas.offsetTop;

            // Adjust posX and posY to keep the canvas centered on the mouse pointer
            posX -= (mouseX - posX) * (delta - 1);
            posY -= (mouseY - posY) * (delta - 1);

            scale = newScale;
            draw();
        }
      };

      canvas.addEventListener('touchstart', handleTouchStart);
      canvas.addEventListener('touchmove', handleTouchMove);
      canvas.addEventListener('touchend', handleTouchEnd);

      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('wheel', handleMouseWheel);
      
      draw();
    </script>
{% endblock %}